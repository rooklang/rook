;; rook1-reg - an interpreted bootstrapping compiler
;;             for the Rook Lisp programming language.
;;
;; This implementation of _Rook[1]_ targets a virtual
;; register machine, called (tenatively) RASM.
;;
;; author:  James Hunt <james@niftylogic.com>
;; created: 2018-06-07
;; updated: 2019-07-29
;;

(let ((*label* 0)
      (*register* 0))
  (functions
    ((bail (error)
       "Bail out with an error.

        The error will be printed to standard error,
        on one or more lines, and the process will end
        with an exit code of 1."
       (printf "error: ")
       (printf error)
       (printf "\n")
       (syscall 'exit 1))

     ;; shorthand for (car (cdr ...)) combinations.
     (caar (x) (car (car x)))
     (cadr (x) (car (cdr x)))
     (caddr (x) (car (cdr (cdr x))))
     (cadddr (x) (car (cdr (cdr (cdr x)))))

     (newlabel ()
       "Create a new RASM label.

        Labels in RASM are globally unique.
        This function guarantees this uniqueness when
        generating new labels, for jumps and conditional
        moves.  It relies on the `*label*` global variable."
       (list 'label (+1 *label*)))

     (newreg ()
       "Create a new RASM register.

        The initial translation of S-expressions into a
        linearized pseudo-assembler dialect assumes that
        the target (virtual) machine has an unlimited set
        of registers.  Future passes of the compiler can
        improve this situation and more efficiently target
        actual machine hardware."
       (list 'register (+1 *register*)))

     (emit (l)
       "Emit RASM code to standard output.

        All NOP placeholders will be ignored during this
        process, as a primitive peephole optimization that
        allows the generative parts of the compiler to
        create sub-optimal code for simplicity's sake."
       (cond ((null l) #t)
             ((eq 'nop (caar l))
              (emit (cdr l)))

             (#t
              (print (car l))
              (emit (cdr l)))))

     (flatten (l)
       "Flatten out a complex list into a simple list.

        To simplify this implementation, I chose to have
        the generative parts of the Rook[1] compiler
        create tree-structure assembler codes, and then
        rely on linearizing this 'bumpy' list via this
        flatten operation."
       (cond ((null l) nil)

             ((atom (car l))
              (cons (car l) (flatten (cdr l))))

             ((atom (caar l))
              (cons (car l) (flatten (cdr l))))

             (#t (append (flatten (car l))
                         (flatten (cdr l))))))

     (gencond (e ift iff)
       "Generate a conditional jump, to one of two labels.

        The `ift` and `iff` arguments are taken as label names,
        as returned by the `(newlabel ...)` function.  The `e`
        code will expand into one or more predicate evaluations
        (all in RASM).

        Atoms are equated checked against nil (nil -> iff).

        For `(eq a b)` forms, evaluative code for the operands
        is generated, and then a comparison je/jmp is made.

        For `(not e)` forms, a recursive call to `(gencond)` is
        made, swapping the `ift` and `iff` labels to express
        the negation.

        For `(and x y)` forms, a new label is introduced for the
        interim if-true branch that evalutes `x`, and two more
        calls to `(gencond)` are stitched together.

        For `(or x y)` forms, a new label is introduced for the
        interim if-false (short-circuit) branch that evalutes `x`,
        and two more calls to `(gencond)` are stitched together.

        Any other input will bail the compiler."
       (cond ((atom e)
              (gencond (list 'not (list 'eq e 'nil)) ift iff))

             ((eq (car e) 'eq)
              (let ((r1 (newreg))
                    (r2 (newreg)))
                (list
                  (geneval r1 (cadr e))
                  (geneval r2 (caddr e))
                  (list 'cmp r1 r2)
                  (list 'je ift)
                  (list 'jmp iff))))

             ((eq (car e) 'not)
              (gencond (cadr e) iff ift))

             ((eq (car e) 'and)
              (let ((lbl (newlabel)))
                (list
                  (gencond (cadr e) lbl iff)
                  lbl
                  (genond (caddr e) ift iff))))

             ((eq (car e) 'or)
              (let ((lbl (newlabel)))
                (list
                  (gencond (cadr e) ift lbl)
                  lbl
                  (gencond (caddr e) ift iff))))

             (#t
               (list
                 (list 'error "unrecognized sub-expression" e)))))

     (geneval (r e)
       "Generate code for the evaluation process."
       (cond ((atom e)
              (list
                (list 'load r e)))

             ((eq (car e) 'if)
              (let ((ift (newlabel))
                    (iff (newlabel))
                    (end (newlabel)))
                (list
                  (gencond (cadr e) ift iff)
                  ift
                  (geneval r (caddr e))
                  (list 'jmp end)
                  iff
                  (geneval r (cadddr e))
                  end
                  (list 'nop))))

             ((eq (car e) 'printf)
                (list
                  (geneval r (cadr e))
                  (list 'printf r)))

             (#t
               (list
                 (list 'error "unhandled-toplevel" e)))))

     (main ()
       (let ((fd (cond ((ne 1 (args))
                        (bail "USAGE: rook0 rook1.rk <script>"))
                       ((eq (argn 0) "-")
                        0)
                       (#t
                        (open (argn 0))))))
         (progn
           (emit (flatten (geneval (newreg) (read fd))))
           (syscall 'exit 0)))))

     (main)))
