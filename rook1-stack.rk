;; rook1-stack - an interpreted bootstrapping compiler
;;               for the Rook Lisp programming language.
;;
;; This implementation of _Rook[1]_ targets a virtual
;; stack machine.
;;
;; author:  James Hunt <james@niftylogic.com>
;; created: 2019-07-29
;;

(let ((*label* 0)
      (*fn* (list)))
  (functions
    ((bail (error)
       "Bail out with an error.

        The error will be printed to standard error,
        on one or more lines, and the process will end
        with an exit code of 1."
       (printf "error: ")
       (printf error)
       (printf "\n")
       (syscall 'exit 1))

     ;; shorthand for (car (cdr ...)) combinations.
     (caar (x) (car (car x)))
     (cadr (x) (car (cdr x)))
     (cdar (x) (cdr (car x)))
     (caddr (x) (car (cdr (cdr x))))
     (caadr (x) (car (car (cdr x))))
     (cadddr (x) (car (cdr (cdr (cdr x)))))

     (newlabel ()
       "Create a new RASM label.

        Labels in RASM are globally unique.
        This function guarantees this uniqueness when
        generating new labels, for jumps and conditional
        moves.  It relies on the `*label*` global variable."
       (list 'label (+1 *label*)))

     (emit (l)
       "Emit RASM code to standard output.

        All NOP placeholders will be ignored during this
        process, as a primitive peephole optimization that
        allows the generative parts of the compiler to
        create sub-optimal code for simplicity's sake."
       (cond ((null l) #t)
             ((eq 'nop (caar l))
              (emit (cdr l)))

             (#t
              (print (car l))
              (emit (cdr l)))))

     (flatten (l)
       "Flatten out a complex list into a simple list.

        To simplify this implementation, I chose to have
        the generative parts of the Rook[1] compiler
        create tree-structure assembler codes, and then
        rely on linearizing this 'bumpy' list via this
        flatten operation."
       (cond ((null l) nil)

             ((atom (car l))
              (cons (car l) (flatten (cdr l))))

             ((atom (caar l))
              (cons (car l) (flatten (cdr l))))

             (#t (append (flatten (car l))
                         (flatten (cdr l))))))

     (find-fn (name lst)
       (cond ((null lst)
              (list 'error "undefined function"))

             ((eq (caar lst) name)
              (cdar lst))

             (#t
              (find-fn name (cdr lst)))))

     (gencond (e ift iff)
       "Generate a conditional jump, to one of two labels.

        The `ift` and `iff` arguments are taken as label names,
        as returned by the `(newlabel ...)` function.  The `e`
        code will expand into one or more predicate evaluations
        (all in RASM).

        Atoms are equated checked against nil (nil -> iff).

        For `(eq a b)` forms, evaluative code for the operands
        is generated, and then a comparison je/jmp is made.

        For `(not e)` forms, a recursive call to `(gencond)` is
        made, swapping the `ift` and `iff` labels to express
        the negation.

        For `(and x y)` forms, a new label is introduced for the
        interim if-true branch that evalutes `x`, and two more
        calls to `(gencond)` are stitched together.

        For `(or x y)` forms, a new label is introduced for the
        interim if-false (short-circuit) branch that evalutes `x`,
        and two more calls to `(gencond)` are stitched together.

        Any other input will bail the compiler."
       (cond ((atom e)
              (gencond (list 'not (list 'eq e 'nil)) ift iff))

             ((eq (car e) 'eq)
              (list
                (geneval (cadr e))
                (geneval (caddr e))
                (list 'cmp)
                (list 'je ift)
                (list 'jmp iff)))

             ((eq (car e) 'not)
              (gencond (cadr e) iff ift))

             ((eq (car e) 'and)
              (let ((lbl (newlabel)))
                (list
                  (gencond (cadr e) lbl iff)
                  lbl
                  (genond (caddr e) ift iff))))

             ((eq (car e) 'or)
              (let ((lbl (newlabel)))
                (list
                  (gencond (cadr e) ift lbl)
                  lbl
                  (gencond (caddr e) ift iff))))

             (#t
               (list
                 (list 'error "unrecognized sub-expression" e)))))

     (geneval (e)
       "Generate code for the evaluation process."
       (cond ((atom e)
              (list
                (list 'push e)))

             ((eq (car e) 'if)
              (let ((ift (newlabel))
                    (iff (newlabel))
                    (end (newlabel)))
                (list
                  (gencond (cadr e) ift iff)
                  ift
                  (geneval (caddr e))
                  (list 'jmp end)
                  iff
                  (geneval (cadddr e))
                  end
                  (list 'nop))))

             ((eq (car e) 'printf)
                (list
                  (geneval (cadr e))
                  (list 'printf)))

             ((eq (car e) '-)
              (list
                (geneval (cadr e))
                (geneval (caddr e))
                (list 'isub)))

             ((eq (car e) '+)
              (list
                (geneval (cadr e))
                (geneval (caddr e))
                (list 'iadd)))

             ((eq (car e) 'fn)
              (let ((fn (newlabel)))
                (progn
                  (setf *fn* (cons (cons (caadr e) fn) *fn*))
                  (list
                    fn
                    (genlambda (cadr e)
                               (caddr e))))))

             (#t
               (let ((fn (find-fn (car e) *fn*)))
                 (cond ((null fn)
                        (list 'error "unhandled-toplevel" e))
                       (#t
                        (gencall fn (cdr e) 0)))))))

     (gencall (fn actuals nargs)
        (cond ((null actuals)
               (list 'call fn nargs))

              (#t
               (list
                 (geneval (car actuals))
                 (gencall fn (cdr actuals) (+1 nargs))))))

     (genlambda (args body)
       "Generate the body of a function block."
       (list (geneval body)
             (list 'ret)))

     (main ()
       (let ((fd (cond ((ne 1 (args))
                        (bail "USAGE: rook0 rook1.rk <script>"))
                       ((eq (argn 0) "-")
                        0)
                       (#t
                        (open (argn 0))))))
         (progn
           (emit (flatten (geneval (read fd))))
           (syscall 'exit 0)))))

     (main)))
