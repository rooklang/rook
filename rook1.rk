;; rook1 - an interpreted bootstrapping compiler
;;         for the Rook Lisp programming language.
;;
;; author:  James Hunt <james@niftylogic.com>
;; created: 2018-06-07
;;

(let ((*label* 0)
      (*register* 0))
  (functions
    ((bail (error)
       "Bail out with an error.

        The error will be printed to standard error,
        on one or more lines, and the process will end
        with an exit code of 1."
       (printf "error: ")
       (printf error)
       (printf "\n")
       (syscall 'exit 1))

     ;; shorthand for (car (cdr ...)) combinations.
     (caar (x) (car (car x)))
     (cadr (x) (car (cdr x)))
     (caddr (x) (car (cdr (cdr x))))
     (cadddr (x) (car (cdr (cdr (cdr x)))))

     (newlabel ()
       "Create a new RASM label.

        Labels in RASM are globally unique.
        This function guarantees this uniqueness when
        generating new labels, for jumps and conditional
        moves.  It relies on the `*label*` global variable."
       (list 'label (+1 *label*)))

     (emit (l)
       "Emit RASM code to standard output.

        All NOP placeholders will be ignored during this
        process, as a primitive peephole optimization that
        allows the generative parts of the compiler to
        create sub-optimal code for simplicity's sake."
       (cond ((null l) #t)
             ((eq 'nop (caar l))
              (emit (cdr l)))

             (#t
              (print (car l))
              (emit (cdr l)))))

     (flatten (l)
       "Flatten out a complex list into a simple list.

        To simplify this implementation, I chose to have
        the generative parts of the Rook[1] compiler
        create tree-structure assembler codes, and then
        rely on linearizing this 'bumpy' list via this
        flatten operation."
       (cond ((null l) nil)

             ((atom (car l))
              (cons (car l) (flatten (cdr l))))

             ((atom (caar l))
              (cons (car l) (flatten (cdr l))))

             (#t (append (flatten (car l))
                         (flatten (cdr l))))))

     (gencond (e ift iff)
       (cond ((atom e)
              (gencond (list 'not (list 'eq e 'nil)) ift iff))

             ((eq (car e) 'eq)
              (list
                (geneval 'r1 (cadr e))
                (geneval 'r2 (caddr e))
                (list 'cmp 'r1 'r2)
                (list 'je ift)
                (list 'jmp iff)))

             ((eq (car e) 'not)
              (gencond (cadr e) iff ift))

             ((eq (car e) 'and)
              (let ((lbl (newlabel)))
                (list
                  (gencond (cadr e) lbl iff)
                  lbl
                  (genond (caddr e) ift iff))))

             ((eq (car e) 'or)
              (let ((lbl (newlabel)))
                (list
                  (gencond (cadr e) ift lbl)
                  lbl
                  (gencond (caddr e) ift iff))))

             (#t
               (list
                 (list 'error "unrecognized sub-expression" e)))))

     (geneval (r e)
       "Generate code for the evaluation process."
       (cond ((atom e)
              (list
                (list 'load r e)))

             ((eq (car e) 'if)
              (let ((ift (newlabel))
                    (iff (newlabel))
                    (end (newlabel)))
                (list
                  (gencond (cadr e) ift iff)
                  ift
                  (geneval r (caddr e))
                  (list 'jmp end)
                  iff
                  (geneval r (cadddr e))
                  end
                  (list 'nop))))

             ((eq (car e) 'printf)
                (list
                  (geneval r (cadr e))
                  (list 'printf)))

             (#t
               (list
                 (list 'error "unhandled-toplevel" e)))))

     (main ()
       (cond ((eq (args) 1) #t)
             (#t (bail "USAGE: rook0 rook1.rk <script>")))
       (emit (flatten (geneval 'r1 (read (open (argn 0))))))
       (syscall 'exit 0)))

     (main)))
